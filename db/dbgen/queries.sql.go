// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package dbgen

import (
	"context"
	"time"
)

const countActivePixels = `-- name: CountActivePixels :one
SELECT COUNT(DISTINCT grid_cell_id) as count FROM effort_data WHERE year = ?
`

func (q *Queries) CountActivePixels(ctx context.Context, year int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActivePixels, year)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createGPXUpload = `-- name: CreateGPXUpload :one
INSERT INTO gpx_uploads (user_id, filename, movement_type, protected_area_id, upload_date, start_time, end_time, total_distance_km, total_points)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id
`

type CreateGPXUploadParams struct {
	UserID          string     `json:"user_id"`
	Filename        string     `json:"filename"`
	MovementType    string     `json:"movement_type"`
	ProtectedAreaID *string    `json:"protected_area_id"`
	UploadDate      time.Time  `json:"upload_date"`
	StartTime       *time.Time `json:"start_time"`
	EndTime         *time.Time `json:"end_time"`
	TotalDistanceKm float64    `json:"total_distance_km"`
	TotalPoints     int64      `json:"total_points"`
}

func (q *Queries) CreateGPXUpload(ctx context.Context, arg CreateGPXUploadParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createGPXUpload,
		arg.UserID,
		arg.Filename,
		arg.MovementType,
		arg.ProtectedAreaID,
		arg.UploadDate,
		arg.StartTime,
		arg.EndTime,
		arg.TotalDistanceKm,
		arg.TotalPoints,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createSession = `-- name: CreateSession :exec
INSERT INTO sessions (id, user_id, created_at, expires_at)
VALUES (?, ?, ?, ?)
`

type CreateSessionParams struct {
	ID        string    `json:"id"`
	UserID    string    `json:"user_id"`
	CreatedAt time.Time `json:"created_at"`
	ExpiresAt time.Time `json:"expires_at"`
}

// Session queries
func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) error {
	_, err := q.db.ExecContext(ctx, createSession,
		arg.ID,
		arg.UserID,
		arg.CreatedAt,
		arg.ExpiresAt,
	)
	return err
}

const createTrackPoint = `-- name: CreateTrackPoint :exec
INSERT INTO track_points (upload_id, lat, lon, elevation, timestamp, grid_cell_id)
VALUES (?, ?, ?, ?, ?, ?)
`

type CreateTrackPointParams struct {
	UploadID   int64      `json:"upload_id"`
	Lat        float64    `json:"lat"`
	Lon        float64    `json:"lon"`
	Elevation  *float64   `json:"elevation"`
	Timestamp  *time.Time `json:"timestamp"`
	GridCellID *string    `json:"grid_cell_id"`
}

func (q *Queries) CreateTrackPoint(ctx context.Context, arg CreateTrackPointParams) error {
	_, err := q.db.ExecContext(ctx, createTrackPoint,
		arg.UploadID,
		arg.Lat,
		arg.Lon,
		arg.Elevation,
		arg.Timestamp,
		arg.GridCellID,
	)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (id, email, name, organization, organization_type, role, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateUserParams struct {
	ID               string    `json:"id"`
	Email            string    `json:"email"`
	Name             string    `json:"name"`
	Organization     string    `json:"organization"`
	OrganizationType string    `json:"organization_type"`
	Role             string    `json:"role"`
	CreatedAt        time.Time `json:"created_at"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.ExecContext(ctx, createUser,
		arg.ID,
		arg.Email,
		arg.Name,
		arg.Organization,
		arg.OrganizationType,
		arg.Role,
		arg.CreatedAt,
	)
	return err
}

const deleteExpiredSessions = `-- name: DeleteExpiredSessions :exec
DELETE FROM sessions WHERE expires_at <= CURRENT_TIMESTAMP
`

func (q *Queries) DeleteExpiredSessions(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredSessions)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions WHERE id = ?
`

func (q *Queries) DeleteSession(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteSession, id)
	return err
}

const deleteUserSessions = `-- name: DeleteUserSessions :exec
DELETE FROM sessions WHERE user_id = ?
`

func (q *Queries) DeleteUserSessions(ctx context.Context, userID string) error {
	_, err := q.db.ExecContext(ctx, deleteUserSessions, userID)
	return err
}

const getChecklistStats = `-- name: GetChecklistStats :one
SELECT 
    COUNT(*) as total,
    SUM(CASE WHEN status = 'complete' THEN 1 ELSE 0 END) as complete,
    SUM(CASE WHEN status = 'in_progress' THEN 1 ELSE 0 END) as in_progress,
    SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending
FROM park_checklist WHERE pa_id = ?
`

type GetChecklistStatsRow struct {
	Total      int64    `json:"total"`
	Complete   *float64 `json:"complete"`
	InProgress *float64 `json:"in_progress"`
	Pending    *float64 `json:"pending"`
}

func (q *Queries) GetChecklistStats(ctx context.Context, paID string) (GetChecklistStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getChecklistStats, paID)
	var i GetChecklistStatsRow
	err := row.Scan(
		&i.Total,
		&i.Complete,
		&i.InProgress,
		&i.Pending,
	)
	return i, err
}

const getEffortDataByBounds = `-- name: GetEffortDataByBounds :many
SELECT e.id, e.grid_cell_id, e.year, e.month, e.day, e.movement_type, e.total_distance_km, e.total_points, e.unique_uploads, e.protected_area_ids, e.coverage_percent, g.lat_center, g.lon_center, g.lat_min, g.lat_max, g.lon_min, g.lon_max
FROM effort_data e
JOIN grid_cells g ON e.grid_cell_id = g.id
WHERE g.lat_center >= ? AND g.lat_center <= ?
  AND g.lon_center >= ? AND g.lon_center <= ?
  AND e.year >= ? AND e.year <= ?
  AND (? IS NULL OR e.month = ?)
  AND (? IS NULL OR e.movement_type = ?)
`

type GetEffortDataByBoundsParams struct {
	LatCenter    float64     `json:"lat_center"`
	LatCenter_2  float64     `json:"lat_center_2"`
	LonCenter    float64     `json:"lon_center"`
	LonCenter_2  float64     `json:"lon_center_2"`
	Year         int64       `json:"year"`
	Year_2       int64       `json:"year_2"`
	Column7      interface{} `json:"column_7"`
	Month        int64       `json:"month"`
	Column9      interface{} `json:"column_9"`
	MovementType string      `json:"movement_type"`
}

type GetEffortDataByBoundsRow struct {
	ID               int64    `json:"id"`
	GridCellID       string   `json:"grid_cell_id"`
	Year             int64    `json:"year"`
	Month            int64    `json:"month"`
	Day              *int64   `json:"day"`
	MovementType     string   `json:"movement_type"`
	TotalDistanceKm  float64  `json:"total_distance_km"`
	TotalPoints      int64    `json:"total_points"`
	UniqueUploads    int64    `json:"unique_uploads"`
	ProtectedAreaIds *string  `json:"protected_area_ids"`
	CoveragePercent  *float64 `json:"coverage_percent"`
	LatCenter        float64  `json:"lat_center"`
	LonCenter        float64  `json:"lon_center"`
	LatMin           float64  `json:"lat_min"`
	LatMax           float64  `json:"lat_max"`
	LonMin           float64  `json:"lon_min"`
	LonMax           float64  `json:"lon_max"`
}

func (q *Queries) GetEffortDataByBounds(ctx context.Context, arg GetEffortDataByBoundsParams) ([]GetEffortDataByBoundsRow, error) {
	rows, err := q.db.QueryContext(ctx, getEffortDataByBounds,
		arg.LatCenter,
		arg.LatCenter_2,
		arg.LonCenter,
		arg.LonCenter_2,
		arg.Year,
		arg.Year_2,
		arg.Column7,
		arg.Month,
		arg.Column9,
		arg.MovementType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEffortDataByBoundsRow{}
	for rows.Next() {
		var i GetEffortDataByBoundsRow
		if err := rows.Scan(
			&i.ID,
			&i.GridCellID,
			&i.Year,
			&i.Month,
			&i.Day,
			&i.MovementType,
			&i.TotalDistanceKm,
			&i.TotalPoints,
			&i.UniqueUploads,
			&i.ProtectedAreaIds,
			&i.CoveragePercent,
			&i.LatCenter,
			&i.LonCenter,
			&i.LatMin,
			&i.LatMax,
			&i.LonMin,
			&i.LonMax,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEffortDataByYear = `-- name: GetEffortDataByYear :many
SELECT e.id, e.grid_cell_id, e.year, e.month, e.day, e.movement_type, e.total_distance_km, e.total_points, e.unique_uploads, e.protected_area_ids, e.coverage_percent, g.lat_center, g.lon_center
FROM effort_data e
JOIN grid_cells g ON e.grid_cell_id = g.id
WHERE e.year = ? AND e.day IS NULL AND e.movement_type = 'all'
`

type GetEffortDataByYearRow struct {
	ID               int64    `json:"id"`
	GridCellID       string   `json:"grid_cell_id"`
	Year             int64    `json:"year"`
	Month            int64    `json:"month"`
	Day              *int64   `json:"day"`
	MovementType     string   `json:"movement_type"`
	TotalDistanceKm  float64  `json:"total_distance_km"`
	TotalPoints      int64    `json:"total_points"`
	UniqueUploads    int64    `json:"unique_uploads"`
	ProtectedAreaIds *string  `json:"protected_area_ids"`
	CoveragePercent  *float64 `json:"coverage_percent"`
	LatCenter        float64  `json:"lat_center"`
	LonCenter        float64  `json:"lon_center"`
}

func (q *Queries) GetEffortDataByYear(ctx context.Context, year int64) ([]GetEffortDataByYearRow, error) {
	rows, err := q.db.QueryContext(ctx, getEffortDataByYear, year)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEffortDataByYearRow{}
	for rows.Next() {
		var i GetEffortDataByYearRow
		if err := rows.Scan(
			&i.ID,
			&i.GridCellID,
			&i.Year,
			&i.Month,
			&i.Day,
			&i.MovementType,
			&i.TotalDistanceKm,
			&i.TotalPoints,
			&i.UniqueUploads,
			&i.ProtectedAreaIds,
			&i.CoveragePercent,
			&i.LatCenter,
			&i.LonCenter,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEffortDataByYearMonth = `-- name: GetEffortDataByYearMonth :many
SELECT e.id, e.grid_cell_id, e.year, e.month, e.day, e.movement_type, e.total_distance_km, e.total_points, e.unique_uploads, e.protected_area_ids, e.coverage_percent, g.lat_center, g.lon_center
FROM effort_data e
JOIN grid_cells g ON e.grid_cell_id = g.id
WHERE e.year = ? AND e.month = ? AND e.day IS NULL AND e.movement_type = 'all'
`

type GetEffortDataByYearMonthParams struct {
	Year  int64 `json:"year"`
	Month int64 `json:"month"`
}

type GetEffortDataByYearMonthRow struct {
	ID               int64    `json:"id"`
	GridCellID       string   `json:"grid_cell_id"`
	Year             int64    `json:"year"`
	Month            int64    `json:"month"`
	Day              *int64   `json:"day"`
	MovementType     string   `json:"movement_type"`
	TotalDistanceKm  float64  `json:"total_distance_km"`
	TotalPoints      int64    `json:"total_points"`
	UniqueUploads    int64    `json:"unique_uploads"`
	ProtectedAreaIds *string  `json:"protected_area_ids"`
	CoveragePercent  *float64 `json:"coverage_percent"`
	LatCenter        float64  `json:"lat_center"`
	LonCenter        float64  `json:"lon_center"`
}

func (q *Queries) GetEffortDataByYearMonth(ctx context.Context, arg GetEffortDataByYearMonthParams) ([]GetEffortDataByYearMonthRow, error) {
	rows, err := q.db.QueryContext(ctx, getEffortDataByYearMonth, arg.Year, arg.Month)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEffortDataByYearMonthRow{}
	for rows.Next() {
		var i GetEffortDataByYearMonthRow
		if err := rows.Scan(
			&i.ID,
			&i.GridCellID,
			&i.Year,
			&i.Month,
			&i.Day,
			&i.MovementType,
			&i.TotalDistanceKm,
			&i.TotalPoints,
			&i.UniqueUploads,
			&i.ProtectedAreaIds,
			&i.CoveragePercent,
			&i.LatCenter,
			&i.LonCenter,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGPXUpload = `-- name: GetGPXUpload :one
SELECT id, user_id, filename, movement_type, protected_area_id, upload_date, start_time, end_time, total_distance_km, total_points FROM gpx_uploads WHERE id = ?
`

func (q *Queries) GetGPXUpload(ctx context.Context, id int64) (GpxUpload, error) {
	row := q.db.QueryRowContext(ctx, getGPXUpload, id)
	var i GpxUpload
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Filename,
		&i.MovementType,
		&i.ProtectedAreaID,
		&i.UploadDate,
		&i.StartTime,
		&i.EndTime,
		&i.TotalDistanceKm,
		&i.TotalPoints,
	)
	return i, err
}

const getGlobalStats = `-- name: GetGlobalStats :one
SELECT 
    COUNT(DISTINCT e.grid_cell_id) as active_pixels,
    COALESCE(SUM(e.total_distance_km), 0) as total_distance_km,
    COALESCE(SUM(e.total_points), 0) as total_points,
    COALESCE(SUM(e.unique_uploads), 0) as total_uploads
FROM effort_data e
WHERE e.year = ? AND e.day IS NULL AND e.movement_type = 'all'
`

type GetGlobalStatsRow struct {
	ActivePixels    int64       `json:"active_pixels"`
	TotalDistanceKm interface{} `json:"total_distance_km"`
	TotalPoints     interface{} `json:"total_points"`
	TotalUploads    interface{} `json:"total_uploads"`
}

func (q *Queries) GetGlobalStats(ctx context.Context, year int64) (GetGlobalStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getGlobalStats, year)
	var i GetGlobalStatsRow
	err := row.Scan(
		&i.ActivePixels,
		&i.TotalDistanceKm,
		&i.TotalPoints,
		&i.TotalUploads,
	)
	return i, err
}

const getGridCell = `-- name: GetGridCell :one
SELECT id, lat_center, lon_center, lat_min, lat_max, lon_min, lon_max FROM grid_cells WHERE id = ?
`

func (q *Queries) GetGridCell(ctx context.Context, id string) (GridCell, error) {
	row := q.db.QueryRowContext(ctx, getGridCell, id)
	var i GridCell
	err := row.Scan(
		&i.ID,
		&i.LatCenter,
		&i.LonCenter,
		&i.LatMin,
		&i.LatMax,
		&i.LonMin,
		&i.LonMax,
	)
	return i, err
}

const getOrCreateGridCell = `-- name: GetOrCreateGridCell :one
INSERT INTO grid_cells (id, lat_center, lon_center, lat_min, lat_max, lon_min, lon_max)
VALUES (?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET id = excluded.id
RETURNING id, lat_center, lon_center, lat_min, lat_max, lon_min, lon_max
`

type GetOrCreateGridCellParams struct {
	ID        string  `json:"id"`
	LatCenter float64 `json:"lat_center"`
	LonCenter float64 `json:"lon_center"`
	LatMin    float64 `json:"lat_min"`
	LatMax    float64 `json:"lat_max"`
	LonMin    float64 `json:"lon_min"`
	LonMax    float64 `json:"lon_max"`
}

func (q *Queries) GetOrCreateGridCell(ctx context.Context, arg GetOrCreateGridCellParams) (GridCell, error) {
	row := q.db.QueryRowContext(ctx, getOrCreateGridCell,
		arg.ID,
		arg.LatCenter,
		arg.LonCenter,
		arg.LatMin,
		arg.LatMax,
		arg.LonMin,
		arg.LonMax,
	)
	var i GridCell
	err := row.Scan(
		&i.ID,
		&i.LatCenter,
		&i.LonCenter,
		&i.LatMin,
		&i.LatMax,
		&i.LonMin,
		&i.LonMax,
	)
	return i, err
}

const getParkChecklistItems = `-- name: GetParkChecklistItems :many

SELECT id, pa_id, item_id, status, notes, document_url, updated_by, updated_at FROM park_checklist WHERE pa_id = ? ORDER BY item_id
`

// Park checklist queries
func (q *Queries) GetParkChecklistItems(ctx context.Context, paID string) ([]ParkChecklist, error) {
	rows, err := q.db.QueryContext(ctx, getParkChecklistItems, paID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ParkChecklist{}
	for rows.Next() {
		var i ParkChecklist
		if err := rows.Scan(
			&i.ID,
			&i.PaID,
			&i.ItemID,
			&i.Status,
			&i.Notes,
			&i.DocumentUrl,
			&i.UpdatedBy,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getParkDocuments = `-- name: GetParkDocuments :many
SELECT id, pa_id, category, item_id, title, description, file_url, file_type, uploaded_by, uploaded_at FROM park_documents WHERE pa_id = ? ORDER BY uploaded_at DESC
`

func (q *Queries) GetParkDocuments(ctx context.Context, paID string) ([]ParkDocument, error) {
	rows, err := q.db.QueryContext(ctx, getParkDocuments, paID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ParkDocument{}
	for rows.Next() {
		var i ParkDocument
		if err := rows.Scan(
			&i.ID,
			&i.PaID,
			&i.Category,
			&i.ItemID,
			&i.Title,
			&i.Description,
			&i.FileUrl,
			&i.FileType,
			&i.UploadedBy,
			&i.UploadedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSession = `-- name: GetSession :one
SELECT s.id, s.user_id, s.created_at, s.expires_at, u.email, u.name, u.role 
FROM sessions s
JOIN users u ON s.user_id = u.id
WHERE s.id = ? AND s.expires_at > CURRENT_TIMESTAMP
`

type GetSessionRow struct {
	ID        string    `json:"id"`
	UserID    string    `json:"user_id"`
	CreatedAt time.Time `json:"created_at"`
	ExpiresAt time.Time `json:"expires_at"`
	Email     string    `json:"email"`
	Name      string    `json:"name"`
	Role      string    `json:"role"`
}

func (q *Queries) GetSession(ctx context.Context, id string) (GetSessionRow, error) {
	row := q.db.QueryRowContext(ctx, getSession, id)
	var i GetSessionRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Email,
		&i.Name,
		&i.Role,
	)
	return i, err
}

const getSubcellCoverageByDateRange = `-- name: GetSubcellCoverageByDateRange :one
SELECT COUNT(DISTINCT subcell_id) as covered_subcells
FROM subcell_visits
WHERE grid_cell_id = ? AND visit_date >= ? AND visit_date <= ?
`

type GetSubcellCoverageByDateRangeParams struct {
	GridCellID  string    `json:"grid_cell_id"`
	VisitDate   time.Time `json:"visit_date"`
	VisitDate_2 time.Time `json:"visit_date_2"`
}

func (q *Queries) GetSubcellCoverageByDateRange(ctx context.Context, arg GetSubcellCoverageByDateRangeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getSubcellCoverageByDateRange, arg.GridCellID, arg.VisitDate, arg.VisitDate_2)
	var covered_subcells int64
	err := row.Scan(&covered_subcells)
	return covered_subcells, err
}

const getSubcellVisitsByDateRange = `-- name: GetSubcellVisitsByDateRange :many
SELECT grid_cell_id, subcell_id, visit_date, visit_count
FROM subcell_visits
WHERE grid_cell_id = ? AND visit_date >= ? AND visit_date <= ?
ORDER BY visit_date
`

type GetSubcellVisitsByDateRangeParams struct {
	GridCellID  string    `json:"grid_cell_id"`
	VisitDate   time.Time `json:"visit_date"`
	VisitDate_2 time.Time `json:"visit_date_2"`
}

type GetSubcellVisitsByDateRangeRow struct {
	GridCellID string    `json:"grid_cell_id"`
	SubcellID  string    `json:"subcell_id"`
	VisitDate  time.Time `json:"visit_date"`
	VisitCount int64     `json:"visit_count"`
}

func (q *Queries) GetSubcellVisitsByDateRange(ctx context.Context, arg GetSubcellVisitsByDateRangeParams) ([]GetSubcellVisitsByDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getSubcellVisitsByDateRange, arg.GridCellID, arg.VisitDate, arg.VisitDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSubcellVisitsByDateRangeRow{}
	for rows.Next() {
		var i GetSubcellVisitsByDateRangeRow
		if err := rows.Scan(
			&i.GridCellID,
			&i.SubcellID,
			&i.VisitDate,
			&i.VisitCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalDistanceByYear = `-- name: GetTotalDistanceByYear :one
SELECT COALESCE(SUM(total_distance_km), 0) as total FROM effort_data WHERE year = ? AND movement_type = 'all' AND day IS NULL
`

func (q *Queries) GetTotalDistanceByYear(ctx context.Context, year int64) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getTotalDistanceByYear, year)
	var total interface{}
	err := row.Scan(&total)
	return total, err
}

const getTrackPointsByUpload = `-- name: GetTrackPointsByUpload :many
SELECT id, upload_id, lat, lon, elevation, timestamp, grid_cell_id FROM track_points WHERE upload_id = ? ORDER BY timestamp
`

func (q *Queries) GetTrackPointsByUpload(ctx context.Context, uploadID int64) ([]TrackPoint, error) {
	rows, err := q.db.QueryContext(ctx, getTrackPointsByUpload, uploadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TrackPoint{}
	for rows.Next() {
		var i TrackPoint
		if err := rows.Scan(
			&i.ID,
			&i.UploadID,
			&i.Lat,
			&i.Lon,
			&i.Elevation,
			&i.Timestamp,
			&i.GridCellID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT id, email, name, organization, organization_type, role, created_at, approved_at, approved_by, password_hash FROM users WHERE id = ?
`

func (q *Queries) GetUser(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Organization,
		&i.OrganizationType,
		&i.Role,
		&i.CreatedAt,
		&i.ApprovedAt,
		&i.ApprovedBy,
		&i.PasswordHash,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, name, organization, organization_type, role, created_at, approved_at, approved_by, password_hash FROM users WHERE email = ?
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Organization,
		&i.OrganizationType,
		&i.Role,
		&i.CreatedAt,
		&i.ApprovedAt,
		&i.ApprovedBy,
		&i.PasswordHash,
	)
	return i, err
}

const insertParkDocument = `-- name: InsertParkDocument :exec
INSERT INTO park_documents (pa_id, category, item_id, title, description, file_url, file_type, uploaded_by)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertParkDocumentParams struct {
	PaID        string  `json:"pa_id"`
	Category    string  `json:"category"`
	ItemID      *string `json:"item_id"`
	Title       string  `json:"title"`
	Description *string `json:"description"`
	FileUrl     *string `json:"file_url"`
	FileType    *string `json:"file_type"`
	UploadedBy  *string `json:"uploaded_by"`
}

func (q *Queries) InsertParkDocument(ctx context.Context, arg InsertParkDocumentParams) error {
	_, err := q.db.ExecContext(ctx, insertParkDocument,
		arg.PaID,
		arg.Category,
		arg.ItemID,
		arg.Title,
		arg.Description,
		arg.FileUrl,
		arg.FileType,
		arg.UploadedBy,
	)
	return err
}

const listAllGPXUploads = `-- name: ListAllGPXUploads :many
SELECT id, user_id, filename, movement_type, protected_area_id, upload_date, start_time, end_time, total_distance_km, total_points FROM gpx_uploads ORDER BY upload_date DESC LIMIT ? OFFSET ?
`

type ListAllGPXUploadsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListAllGPXUploads(ctx context.Context, arg ListAllGPXUploadsParams) ([]GpxUpload, error) {
	rows, err := q.db.QueryContext(ctx, listAllGPXUploads, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GpxUpload{}
	for rows.Next() {
		var i GpxUpload
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Filename,
			&i.MovementType,
			&i.ProtectedAreaID,
			&i.UploadDate,
			&i.StartTime,
			&i.EndTime,
			&i.TotalDistanceKm,
			&i.TotalPoints,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllUsers = `-- name: ListAllUsers :many
SELECT id, email, name, organization, organization_type, role, created_at, approved_at, approved_by, password_hash FROM users ORDER BY created_at DESC
`

func (q *Queries) ListAllUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.Organization,
			&i.OrganizationType,
			&i.Role,
			&i.CreatedAt,
			&i.ApprovedAt,
			&i.ApprovedBy,
			&i.PasswordHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listApprovedUsers = `-- name: ListApprovedUsers :many
SELECT id, email, name, organization, organization_type, role, created_at, approved_at, approved_by, password_hash FROM users WHERE role IN ('approved', 'admin') ORDER BY created_at DESC
`

func (q *Queries) ListApprovedUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listApprovedUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.Organization,
			&i.OrganizationType,
			&i.Role,
			&i.CreatedAt,
			&i.ApprovedAt,
			&i.ApprovedBy,
			&i.PasswordHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGPXUploadsByUser = `-- name: ListGPXUploadsByUser :many
SELECT id, user_id, filename, movement_type, protected_area_id, upload_date, start_time, end_time, total_distance_km, total_points FROM gpx_uploads WHERE user_id = ? ORDER BY upload_date DESC
`

func (q *Queries) ListGPXUploadsByUser(ctx context.Context, userID string) ([]GpxUpload, error) {
	rows, err := q.db.QueryContext(ctx, listGPXUploadsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GpxUpload{}
	for rows.Next() {
		var i GpxUpload
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Filename,
			&i.MovementType,
			&i.ProtectedAreaID,
			&i.UploadDate,
			&i.StartTime,
			&i.EndTime,
			&i.TotalDistanceKm,
			&i.TotalPoints,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGPXUploadsWithCoords = `-- name: ListGPXUploadsWithCoords :many
SELECT 
    u.id, u.user_id, u.filename, u.movement_type, u.protected_area_id,
    u.upload_date, u.start_time, u.end_time, u.total_distance_km, u.total_points,
    AVG(t.lat) as centroid_lat,
    AVG(t.lon) as centroid_lon
FROM gpx_uploads u
LEFT JOIN track_points t ON u.id = t.upload_id
GROUP BY u.id
ORDER BY u.upload_date DESC
LIMIT ? OFFSET ?
`

type ListGPXUploadsWithCoordsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

type ListGPXUploadsWithCoordsRow struct {
	ID              int64      `json:"id"`
	UserID          string     `json:"user_id"`
	Filename        string     `json:"filename"`
	MovementType    string     `json:"movement_type"`
	ProtectedAreaID *string    `json:"protected_area_id"`
	UploadDate      time.Time  `json:"upload_date"`
	StartTime       *time.Time `json:"start_time"`
	EndTime         *time.Time `json:"end_time"`
	TotalDistanceKm float64    `json:"total_distance_km"`
	TotalPoints     int64      `json:"total_points"`
	CentroidLat     *float64   `json:"centroid_lat"`
	CentroidLon     *float64   `json:"centroid_lon"`
}

func (q *Queries) ListGPXUploadsWithCoords(ctx context.Context, arg ListGPXUploadsWithCoordsParams) ([]ListGPXUploadsWithCoordsRow, error) {
	rows, err := q.db.QueryContext(ctx, listGPXUploadsWithCoords, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListGPXUploadsWithCoordsRow{}
	for rows.Next() {
		var i ListGPXUploadsWithCoordsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Filename,
			&i.MovementType,
			&i.ProtectedAreaID,
			&i.UploadDate,
			&i.StartTime,
			&i.EndTime,
			&i.TotalDistanceKm,
			&i.TotalPoints,
			&i.CentroidLat,
			&i.CentroidLon,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingUsers = `-- name: ListPendingUsers :many
SELECT id, email, name, organization, organization_type, role, created_at, approved_at, approved_by, password_hash FROM users WHERE role = 'pending' ORDER BY created_at DESC
`

func (q *Queries) ListPendingUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listPendingUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.Organization,
			&i.OrganizationType,
			&i.Role,
			&i.CreatedAt,
			&i.ApprovedAt,
			&i.ApprovedBy,
			&i.PasswordHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEffortCoverage = `-- name: UpdateEffortCoverage :exec
UPDATE effort_data SET coverage_percent = ? 
WHERE grid_cell_id = ? AND year = ? AND month = ? AND movement_type = ?
`

type UpdateEffortCoverageParams struct {
	CoveragePercent *float64 `json:"coverage_percent"`
	GridCellID      string   `json:"grid_cell_id"`
	Year            int64    `json:"year"`
	Month           int64    `json:"month"`
	MovementType    string   `json:"movement_type"`
}

func (q *Queries) UpdateEffortCoverage(ctx context.Context, arg UpdateEffortCoverageParams) error {
	_, err := q.db.ExecContext(ctx, updateEffortCoverage,
		arg.CoveragePercent,
		arg.GridCellID,
		arg.Year,
		arg.Month,
		arg.MovementType,
	)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users SET password_hash = ? WHERE id = ?
`

type UpdateUserPasswordParams struct {
	PasswordHash string `json:"password_hash"`
	ID           string `json:"id"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPassword, arg.PasswordHash, arg.ID)
	return err
}

const updateUserRole = `-- name: UpdateUserRole :exec
UPDATE users SET role = ?, approved_at = ?, approved_by = ? WHERE id = ?
`

type UpdateUserRoleParams struct {
	Role       string     `json:"role"`
	ApprovedAt *time.Time `json:"approved_at"`
	ApprovedBy *string    `json:"approved_by"`
	ID         string     `json:"id"`
}

func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) error {
	_, err := q.db.ExecContext(ctx, updateUserRole,
		arg.Role,
		arg.ApprovedAt,
		arg.ApprovedBy,
		arg.ID,
	)
	return err
}

const upsertChecklistItem = `-- name: UpsertChecklistItem :exec
INSERT INTO park_checklist (pa_id, item_id, status, notes, document_url, updated_by, updated_at)
VALUES (?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(pa_id, item_id) DO UPDATE SET
    status = excluded.status,
    notes = excluded.notes,
    document_url = excluded.document_url,
    updated_by = excluded.updated_by,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertChecklistItemParams struct {
	PaID        string  `json:"pa_id"`
	ItemID      string  `json:"item_id"`
	Status      string  `json:"status"`
	Notes       *string `json:"notes"`
	DocumentUrl *string `json:"document_url"`
	UpdatedBy   *string `json:"updated_by"`
}

func (q *Queries) UpsertChecklistItem(ctx context.Context, arg UpsertChecklistItemParams) error {
	_, err := q.db.ExecContext(ctx, upsertChecklistItem,
		arg.PaID,
		arg.ItemID,
		arg.Status,
		arg.Notes,
		arg.DocumentUrl,
		arg.UpdatedBy,
	)
	return err
}

const upsertEffortData = `-- name: UpsertEffortData :exec
INSERT INTO effort_data (grid_cell_id, year, month, day, movement_type, total_distance_km, total_points, unique_uploads, protected_area_ids)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(grid_cell_id, year, month, day, movement_type) DO UPDATE SET
    total_distance_km = effort_data.total_distance_km + excluded.total_distance_km,
    total_points = effort_data.total_points + excluded.total_points,
    unique_uploads = effort_data.unique_uploads + excluded.unique_uploads
`

type UpsertEffortDataParams struct {
	GridCellID       string  `json:"grid_cell_id"`
	Year             int64   `json:"year"`
	Month            int64   `json:"month"`
	Day              *int64  `json:"day"`
	MovementType     string  `json:"movement_type"`
	TotalDistanceKm  float64 `json:"total_distance_km"`
	TotalPoints      int64   `json:"total_points"`
	UniqueUploads    int64   `json:"unique_uploads"`
	ProtectedAreaIds *string `json:"protected_area_ids"`
}

func (q *Queries) UpsertEffortData(ctx context.Context, arg UpsertEffortDataParams) error {
	_, err := q.db.ExecContext(ctx, upsertEffortData,
		arg.GridCellID,
		arg.Year,
		arg.Month,
		arg.Day,
		arg.MovementType,
		arg.TotalDistanceKm,
		arg.TotalPoints,
		arg.UniqueUploads,
		arg.ProtectedAreaIds,
	)
	return err
}

const upsertSubcellVisit = `-- name: UpsertSubcellVisit :exec

INSERT INTO subcell_visits (grid_cell_id, subcell_id, visit_date, visit_count)
VALUES (?, ?, ?, 1)
ON CONFLICT(grid_cell_id, subcell_id, visit_date) DO UPDATE SET
    visit_count = visit_count + 1
`

type UpsertSubcellVisitParams struct {
	GridCellID string    `json:"grid_cell_id"`
	SubcellID  string    `json:"subcell_id"`
	VisitDate  time.Time `json:"visit_date"`
}

// Subcell visits tracking for spatial coverage (day granularity)
func (q *Queries) UpsertSubcellVisit(ctx context.Context, arg UpsertSubcellVisitParams) error {
	_, err := q.db.ExecContext(ctx, upsertSubcellVisit, arg.GridCellID, arg.SubcellID, arg.VisitDate)
	return err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package dbgen

import (
	"context"
	"time"
)

const countActivePixels = `-- name: CountActivePixels :one
SELECT COUNT(DISTINCT grid_cell_id) as count FROM effort_data WHERE year = ?
`

func (q *Queries) CountActivePixels(ctx context.Context, year int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countActivePixels, year)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createGPXUpload = `-- name: CreateGPXUpload :one
INSERT INTO gpx_uploads (user_id, filename, movement_type, protected_area_id, upload_date, start_time, end_time, total_distance_km, total_points)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id
`

type CreateGPXUploadParams struct {
	UserID          string     `json:"user_id"`
	Filename        string     `json:"filename"`
	MovementType    string     `json:"movement_type"`
	ProtectedAreaID *string    `json:"protected_area_id"`
	UploadDate      time.Time  `json:"upload_date"`
	StartTime       *time.Time `json:"start_time"`
	EndTime         *time.Time `json:"end_time"`
	TotalDistanceKm float64    `json:"total_distance_km"`
	TotalPoints     int64      `json:"total_points"`
}

func (q *Queries) CreateGPXUpload(ctx context.Context, arg CreateGPXUploadParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createGPXUpload,
		arg.UserID,
		arg.Filename,
		arg.MovementType,
		arg.ProtectedAreaID,
		arg.UploadDate,
		arg.StartTime,
		arg.EndTime,
		arg.TotalDistanceKm,
		arg.TotalPoints,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createTrackPoint = `-- name: CreateTrackPoint :exec
INSERT INTO track_points (upload_id, lat, lon, elevation, timestamp, grid_cell_id)
VALUES (?, ?, ?, ?, ?, ?)
`

type CreateTrackPointParams struct {
	UploadID   int64      `json:"upload_id"`
	Lat        float64    `json:"lat"`
	Lon        float64    `json:"lon"`
	Elevation  *float64   `json:"elevation"`
	Timestamp  *time.Time `json:"timestamp"`
	GridCellID *string    `json:"grid_cell_id"`
}

func (q *Queries) CreateTrackPoint(ctx context.Context, arg CreateTrackPointParams) error {
	_, err := q.db.ExecContext(ctx, createTrackPoint,
		arg.UploadID,
		arg.Lat,
		arg.Lon,
		arg.Elevation,
		arg.Timestamp,
		arg.GridCellID,
	)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (id, email, name, organization, organization_type, role, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateUserParams struct {
	ID               string    `json:"id"`
	Email            string    `json:"email"`
	Name             string    `json:"name"`
	Organization     string    `json:"organization"`
	OrganizationType string    `json:"organization_type"`
	Role             string    `json:"role"`
	CreatedAt        time.Time `json:"created_at"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.ExecContext(ctx, createUser,
		arg.ID,
		arg.Email,
		arg.Name,
		arg.Organization,
		arg.OrganizationType,
		arg.Role,
		arg.CreatedAt,
	)
	return err
}

const getEffortDataByBounds = `-- name: GetEffortDataByBounds :many
SELECT e.id, e.grid_cell_id, e.year, e.month, e.day, e.movement_type, e.total_distance_km, e.total_points, e.unique_uploads, e.protected_area_ids, g.lat_center, g.lon_center, g.lat_min, g.lat_max, g.lon_min, g.lon_max
FROM effort_data e
JOIN grid_cells g ON e.grid_cell_id = g.id
WHERE g.lat_center >= ? AND g.lat_center <= ?
  AND g.lon_center >= ? AND g.lon_center <= ?
  AND e.year >= ? AND e.year <= ?
  AND (? IS NULL OR e.month = ?)
  AND (? IS NULL OR e.movement_type = ?)
`

type GetEffortDataByBoundsParams struct {
	LatCenter    float64     `json:"lat_center"`
	LatCenter_2  float64     `json:"lat_center_2"`
	LonCenter    float64     `json:"lon_center"`
	LonCenter_2  float64     `json:"lon_center_2"`
	Year         int64       `json:"year"`
	Year_2       int64       `json:"year_2"`
	Column7      interface{} `json:"column_7"`
	Month        int64       `json:"month"`
	Column9      interface{} `json:"column_9"`
	MovementType string      `json:"movement_type"`
}

type GetEffortDataByBoundsRow struct {
	ID               int64   `json:"id"`
	GridCellID       string  `json:"grid_cell_id"`
	Year             int64   `json:"year"`
	Month            int64   `json:"month"`
	Day              *int64  `json:"day"`
	MovementType     string  `json:"movement_type"`
	TotalDistanceKm  float64 `json:"total_distance_km"`
	TotalPoints      int64   `json:"total_points"`
	UniqueUploads    int64   `json:"unique_uploads"`
	ProtectedAreaIds *string `json:"protected_area_ids"`
	LatCenter        float64 `json:"lat_center"`
	LonCenter        float64 `json:"lon_center"`
	LatMin           float64 `json:"lat_min"`
	LatMax           float64 `json:"lat_max"`
	LonMin           float64 `json:"lon_min"`
	LonMax           float64 `json:"lon_max"`
}

func (q *Queries) GetEffortDataByBounds(ctx context.Context, arg GetEffortDataByBoundsParams) ([]GetEffortDataByBoundsRow, error) {
	rows, err := q.db.QueryContext(ctx, getEffortDataByBounds,
		arg.LatCenter,
		arg.LatCenter_2,
		arg.LonCenter,
		arg.LonCenter_2,
		arg.Year,
		arg.Year_2,
		arg.Column7,
		arg.Month,
		arg.Column9,
		arg.MovementType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEffortDataByBoundsRow{}
	for rows.Next() {
		var i GetEffortDataByBoundsRow
		if err := rows.Scan(
			&i.ID,
			&i.GridCellID,
			&i.Year,
			&i.Month,
			&i.Day,
			&i.MovementType,
			&i.TotalDistanceKm,
			&i.TotalPoints,
			&i.UniqueUploads,
			&i.ProtectedAreaIds,
			&i.LatCenter,
			&i.LonCenter,
			&i.LatMin,
			&i.LatMax,
			&i.LonMin,
			&i.LonMax,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEffortDataByYear = `-- name: GetEffortDataByYear :many
SELECT e.id, e.grid_cell_id, e.year, e.month, e.day, e.movement_type, e.total_distance_km, e.total_points, e.unique_uploads, e.protected_area_ids, g.lat_center, g.lon_center
FROM effort_data e
JOIN grid_cells g ON e.grid_cell_id = g.id
WHERE e.year = ? AND e.day IS NULL AND e.movement_type = 'all'
`

type GetEffortDataByYearRow struct {
	ID               int64   `json:"id"`
	GridCellID       string  `json:"grid_cell_id"`
	Year             int64   `json:"year"`
	Month            int64   `json:"month"`
	Day              *int64  `json:"day"`
	MovementType     string  `json:"movement_type"`
	TotalDistanceKm  float64 `json:"total_distance_km"`
	TotalPoints      int64   `json:"total_points"`
	UniqueUploads    int64   `json:"unique_uploads"`
	ProtectedAreaIds *string `json:"protected_area_ids"`
	LatCenter        float64 `json:"lat_center"`
	LonCenter        float64 `json:"lon_center"`
}

func (q *Queries) GetEffortDataByYear(ctx context.Context, year int64) ([]GetEffortDataByYearRow, error) {
	rows, err := q.db.QueryContext(ctx, getEffortDataByYear, year)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEffortDataByYearRow{}
	for rows.Next() {
		var i GetEffortDataByYearRow
		if err := rows.Scan(
			&i.ID,
			&i.GridCellID,
			&i.Year,
			&i.Month,
			&i.Day,
			&i.MovementType,
			&i.TotalDistanceKm,
			&i.TotalPoints,
			&i.UniqueUploads,
			&i.ProtectedAreaIds,
			&i.LatCenter,
			&i.LonCenter,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEffortDataByYearMonth = `-- name: GetEffortDataByYearMonth :many
SELECT e.id, e.grid_cell_id, e.year, e.month, e.day, e.movement_type, e.total_distance_km, e.total_points, e.unique_uploads, e.protected_area_ids, g.lat_center, g.lon_center
FROM effort_data e
JOIN grid_cells g ON e.grid_cell_id = g.id
WHERE e.year = ? AND e.month = ? AND e.day IS NULL AND e.movement_type = 'all'
`

type GetEffortDataByYearMonthParams struct {
	Year  int64 `json:"year"`
	Month int64 `json:"month"`
}

type GetEffortDataByYearMonthRow struct {
	ID               int64   `json:"id"`
	GridCellID       string  `json:"grid_cell_id"`
	Year             int64   `json:"year"`
	Month            int64   `json:"month"`
	Day              *int64  `json:"day"`
	MovementType     string  `json:"movement_type"`
	TotalDistanceKm  float64 `json:"total_distance_km"`
	TotalPoints      int64   `json:"total_points"`
	UniqueUploads    int64   `json:"unique_uploads"`
	ProtectedAreaIds *string `json:"protected_area_ids"`
	LatCenter        float64 `json:"lat_center"`
	LonCenter        float64 `json:"lon_center"`
}

func (q *Queries) GetEffortDataByYearMonth(ctx context.Context, arg GetEffortDataByYearMonthParams) ([]GetEffortDataByYearMonthRow, error) {
	rows, err := q.db.QueryContext(ctx, getEffortDataByYearMonth, arg.Year, arg.Month)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEffortDataByYearMonthRow{}
	for rows.Next() {
		var i GetEffortDataByYearMonthRow
		if err := rows.Scan(
			&i.ID,
			&i.GridCellID,
			&i.Year,
			&i.Month,
			&i.Day,
			&i.MovementType,
			&i.TotalDistanceKm,
			&i.TotalPoints,
			&i.UniqueUploads,
			&i.ProtectedAreaIds,
			&i.LatCenter,
			&i.LonCenter,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGPXUpload = `-- name: GetGPXUpload :one
SELECT id, user_id, filename, movement_type, protected_area_id, upload_date, start_time, end_time, total_distance_km, total_points FROM gpx_uploads WHERE id = ?
`

func (q *Queries) GetGPXUpload(ctx context.Context, id int64) (GpxUpload, error) {
	row := q.db.QueryRowContext(ctx, getGPXUpload, id)
	var i GpxUpload
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Filename,
		&i.MovementType,
		&i.ProtectedAreaID,
		&i.UploadDate,
		&i.StartTime,
		&i.EndTime,
		&i.TotalDistanceKm,
		&i.TotalPoints,
	)
	return i, err
}

const getGlobalStats = `-- name: GetGlobalStats :one
SELECT 
    COUNT(DISTINCT e.grid_cell_id) as active_pixels,
    COALESCE(SUM(e.total_distance_km), 0) as total_distance_km,
    COALESCE(SUM(e.total_points), 0) as total_points,
    COALESCE(SUM(e.unique_uploads), 0) as total_uploads
FROM effort_data e
WHERE e.year = ? AND e.day IS NULL AND e.movement_type = 'all'
`

type GetGlobalStatsRow struct {
	ActivePixels    int64       `json:"active_pixels"`
	TotalDistanceKm interface{} `json:"total_distance_km"`
	TotalPoints     interface{} `json:"total_points"`
	TotalUploads    interface{} `json:"total_uploads"`
}

func (q *Queries) GetGlobalStats(ctx context.Context, year int64) (GetGlobalStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getGlobalStats, year)
	var i GetGlobalStatsRow
	err := row.Scan(
		&i.ActivePixels,
		&i.TotalDistanceKm,
		&i.TotalPoints,
		&i.TotalUploads,
	)
	return i, err
}

const getGridCell = `-- name: GetGridCell :one
SELECT id, lat_center, lon_center, lat_min, lat_max, lon_min, lon_max FROM grid_cells WHERE id = ?
`

func (q *Queries) GetGridCell(ctx context.Context, id string) (GridCell, error) {
	row := q.db.QueryRowContext(ctx, getGridCell, id)
	var i GridCell
	err := row.Scan(
		&i.ID,
		&i.LatCenter,
		&i.LonCenter,
		&i.LatMin,
		&i.LatMax,
		&i.LonMin,
		&i.LonMax,
	)
	return i, err
}

const getOrCreateGridCell = `-- name: GetOrCreateGridCell :one
INSERT INTO grid_cells (id, lat_center, lon_center, lat_min, lat_max, lon_min, lon_max)
VALUES (?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET id = excluded.id
RETURNING id, lat_center, lon_center, lat_min, lat_max, lon_min, lon_max
`

type GetOrCreateGridCellParams struct {
	ID        string  `json:"id"`
	LatCenter float64 `json:"lat_center"`
	LonCenter float64 `json:"lon_center"`
	LatMin    float64 `json:"lat_min"`
	LatMax    float64 `json:"lat_max"`
	LonMin    float64 `json:"lon_min"`
	LonMax    float64 `json:"lon_max"`
}

func (q *Queries) GetOrCreateGridCell(ctx context.Context, arg GetOrCreateGridCellParams) (GridCell, error) {
	row := q.db.QueryRowContext(ctx, getOrCreateGridCell,
		arg.ID,
		arg.LatCenter,
		arg.LonCenter,
		arg.LatMin,
		arg.LatMax,
		arg.LonMin,
		arg.LonMax,
	)
	var i GridCell
	err := row.Scan(
		&i.ID,
		&i.LatCenter,
		&i.LonCenter,
		&i.LatMin,
		&i.LatMax,
		&i.LonMin,
		&i.LonMax,
	)
	return i, err
}

const getTotalDistanceByYear = `-- name: GetTotalDistanceByYear :one
SELECT COALESCE(SUM(total_distance_km), 0) as total FROM effort_data WHERE year = ? AND movement_type = 'all' AND day IS NULL
`

func (q *Queries) GetTotalDistanceByYear(ctx context.Context, year int64) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getTotalDistanceByYear, year)
	var total interface{}
	err := row.Scan(&total)
	return total, err
}

const getTrackPointsByUpload = `-- name: GetTrackPointsByUpload :many
SELECT id, upload_id, lat, lon, elevation, timestamp, grid_cell_id FROM track_points WHERE upload_id = ? ORDER BY timestamp
`

func (q *Queries) GetTrackPointsByUpload(ctx context.Context, uploadID int64) ([]TrackPoint, error) {
	rows, err := q.db.QueryContext(ctx, getTrackPointsByUpload, uploadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TrackPoint{}
	for rows.Next() {
		var i TrackPoint
		if err := rows.Scan(
			&i.ID,
			&i.UploadID,
			&i.Lat,
			&i.Lon,
			&i.Elevation,
			&i.Timestamp,
			&i.GridCellID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT id, email, name, organization, organization_type, role, created_at, approved_at, approved_by FROM users WHERE id = ?
`

func (q *Queries) GetUser(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Organization,
		&i.OrganizationType,
		&i.Role,
		&i.CreatedAt,
		&i.ApprovedAt,
		&i.ApprovedBy,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, name, organization, organization_type, role, created_at, approved_at, approved_by FROM users WHERE email = ?
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Organization,
		&i.OrganizationType,
		&i.Role,
		&i.CreatedAt,
		&i.ApprovedAt,
		&i.ApprovedBy,
	)
	return i, err
}

const listAllGPXUploads = `-- name: ListAllGPXUploads :many
SELECT id, user_id, filename, movement_type, protected_area_id, upload_date, start_time, end_time, total_distance_km, total_points FROM gpx_uploads ORDER BY upload_date DESC LIMIT ? OFFSET ?
`

type ListAllGPXUploadsParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListAllGPXUploads(ctx context.Context, arg ListAllGPXUploadsParams) ([]GpxUpload, error) {
	rows, err := q.db.QueryContext(ctx, listAllGPXUploads, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GpxUpload{}
	for rows.Next() {
		var i GpxUpload
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Filename,
			&i.MovementType,
			&i.ProtectedAreaID,
			&i.UploadDate,
			&i.StartTime,
			&i.EndTime,
			&i.TotalDistanceKm,
			&i.TotalPoints,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllUsers = `-- name: ListAllUsers :many
SELECT id, email, name, organization, organization_type, role, created_at, approved_at, approved_by FROM users ORDER BY created_at DESC
`

func (q *Queries) ListAllUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.Organization,
			&i.OrganizationType,
			&i.Role,
			&i.CreatedAt,
			&i.ApprovedAt,
			&i.ApprovedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listApprovedUsers = `-- name: ListApprovedUsers :many
SELECT id, email, name, organization, organization_type, role, created_at, approved_at, approved_by FROM users WHERE role IN ('approved', 'admin') ORDER BY created_at DESC
`

func (q *Queries) ListApprovedUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listApprovedUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.Organization,
			&i.OrganizationType,
			&i.Role,
			&i.CreatedAt,
			&i.ApprovedAt,
			&i.ApprovedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGPXUploadsByUser = `-- name: ListGPXUploadsByUser :many
SELECT id, user_id, filename, movement_type, protected_area_id, upload_date, start_time, end_time, total_distance_km, total_points FROM gpx_uploads WHERE user_id = ? ORDER BY upload_date DESC
`

func (q *Queries) ListGPXUploadsByUser(ctx context.Context, userID string) ([]GpxUpload, error) {
	rows, err := q.db.QueryContext(ctx, listGPXUploadsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GpxUpload{}
	for rows.Next() {
		var i GpxUpload
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Filename,
			&i.MovementType,
			&i.ProtectedAreaID,
			&i.UploadDate,
			&i.StartTime,
			&i.EndTime,
			&i.TotalDistanceKm,
			&i.TotalPoints,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingUsers = `-- name: ListPendingUsers :many
SELECT id, email, name, organization, organization_type, role, created_at, approved_at, approved_by FROM users WHERE role = 'pending' ORDER BY created_at DESC
`

func (q *Queries) ListPendingUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listPendingUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Name,
			&i.Organization,
			&i.OrganizationType,
			&i.Role,
			&i.CreatedAt,
			&i.ApprovedAt,
			&i.ApprovedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserRole = `-- name: UpdateUserRole :exec
UPDATE users SET role = ?, approved_at = ?, approved_by = ? WHERE id = ?
`

type UpdateUserRoleParams struct {
	Role       string     `json:"role"`
	ApprovedAt *time.Time `json:"approved_at"`
	ApprovedBy *string    `json:"approved_by"`
	ID         string     `json:"id"`
}

func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) error {
	_, err := q.db.ExecContext(ctx, updateUserRole,
		arg.Role,
		arg.ApprovedAt,
		arg.ApprovedBy,
		arg.ID,
	)
	return err
}

const upsertEffortData = `-- name: UpsertEffortData :exec
INSERT INTO effort_data (grid_cell_id, year, month, day, movement_type, total_distance_km, total_points, unique_uploads, protected_area_ids)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(grid_cell_id, year, month, day, movement_type) DO UPDATE SET
    total_distance_km = effort_data.total_distance_km + excluded.total_distance_km,
    total_points = effort_data.total_points + excluded.total_points,
    unique_uploads = effort_data.unique_uploads + excluded.unique_uploads
`

type UpsertEffortDataParams struct {
	GridCellID       string  `json:"grid_cell_id"`
	Year             int64   `json:"year"`
	Month            int64   `json:"month"`
	Day              *int64  `json:"day"`
	MovementType     string  `json:"movement_type"`
	TotalDistanceKm  float64 `json:"total_distance_km"`
	TotalPoints      int64   `json:"total_points"`
	UniqueUploads    int64   `json:"unique_uploads"`
	ProtectedAreaIds *string `json:"protected_area_ids"`
}

func (q *Queries) UpsertEffortData(ctx context.Context, arg UpsertEffortDataParams) error {
	_, err := q.db.ExecContext(ctx, upsertEffortData,
		arg.GridCellID,
		arg.Year,
		arg.Month,
		arg.Day,
		arg.MovementType,
		arg.TotalDistanceKm,
		arg.TotalPoints,
		arg.UniqueUploads,
		arg.ProtectedAreaIds,
	)
	return err
}
